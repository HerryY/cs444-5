\documentclass[titlepage]{article}

\usepackage[T1]{fontenc}
\usepackage[letterpaper, portrait, margin=0.75in]{geometry}
\usepackage[singlespacing]{setspace}
\usepackage{url}
\usepackage{tocloft}
\usepackage{listings}
\usepackage{color}
\setlength{\parindent}{0pt}


\begin{document}
\begin{titlepage}
\centering
{\Huge Final Paper\par}
{\LARGE Taylor Falhman\par}
{\Large CS444 Fall 2015\par}
\end{titlepage}

\section{Processes and Threads}
\begin{singlespace}
    A process is the execution of a program and a fundamental feature     of an operating system. Operating system handles these programs at many levels, including creation, execution, scheduling and threading. Process are given memory and other various metadata attributes so the kernel can reference it.\\ 
    In FreeBSD, a process has at least one thread, with the possibility of having multiple threads. Each thread has two options for execution: user mode and kernel mode, which in turn have corresponding resource structures. The user mode resources are usually general purpose registers, the program counter and the like found in the CPU for all process. The kernel mode in contrast uses the registers and other counters that the hardware typically uses. The kernel state divides these resources into two structures, the process structure and the thread structure. The process structure holds the main information that the kernel needs to know about the process, while the thread structure only holds the information needed at the time of execution, and may not always have information in it.\\
    A process in FreeBSD will contain the following: a process ID, a signal state, tracing information, and timers to keep track of real time and CPU time. Substructures include the calling user's credentials, memory mapping, file descriptors, system call mapping, statistics, and the thread structure to name most of them. Processes are categorized into two groups; a zombie list and an all processes list. Process can be in only one list at a time, and this is only used to make the zombie killing time more efficient. Threads are also categorized into one of three 'queues': the run queue, where runnable threads are placed, the sleep queue, or the turnstile queue. \\
Once a thread has finished its allotted time executing, or is finished, the CPU uses context switching. Context switching means that the CPU is switching execution from one thread to another, which means that the done process will be placed on the sleep or turnstile queue, and one will be move from one of those queues to the running queue.\\
    FreeBSD initially used a threading model called 'N:M threading',but this caused extra overhead. In the end, the developers decided to implement the POSIX threading standard, pthreads. This includes creation, scheduling, and signaling. Threads are created using the pthread create system call. Pthreads from the same parent process all share the same shared memory. Pthreads use the mutex as the main method of multi-threaded programing control. There also exists the fork system call in FreeBSD, in which a process can create a completely separate process, as opposed to just a thread. \\
    The default scheduler for FreeBSD is called the ULE scheduler. It's divided into a low and a high level scheduler. The low level part gets the next highest priority thread in the run queue and sends it to execute. The high level part orders the threads by priority for each CPU. \cite{freebsdch4}\\

    Windows have a slightly different model for what processors and threads do, but there are a multitude of similarities with FreeBSD and POSIX implementations. \\
    Processes are represented by the 'executive process' structure, which in turn holds many other structures full of information about a process. Each executive process also has a corresponding kernel mode data structure, called a W32PROCESS. After all the process structures have been created, a thread must be created. This shows a major difference between the Windows and FreeBSD implementations. FreeBSD treats threads and processes the same in terms of creating a process and execution. But in Windows, a thread is created using a completely different system call, and processes aren't executed, only the threads within them. Processes only provide the context in which the thread will use in its execution in Windows.\\
    This difference probably came about in an attempt to simplify and separate ideas during the implementation of Windows. Since the difference between a process and a thread and small for FreeBSD and it's POSIX-using UNIX cousins, the two can get confusing. Microsoft probably wanted to simplify and break up responsibilities between the process and thread. This also allows developers and users to know exactly what they are looking for in debugging or inspecting the Task Manager.\\
    Windows uses a priority system for its CPU scheduling that FreeBSD does. The priority of affinity is determined by a processor group, unless otherwise set by the developer, which can set the group or affinity using the scheduling API. Thread priority isn't affected by the process it belongs to; the scheduler only sees the total number of threads and tries to give each an equal amount of time on the CPU. \cite{windowsch5}\\
    Priority is based off of two factors: the priority class given at creation time given to the process, and the individual thread priority. Priority can also be increased (or less commonly, decreased) for a number of reasons. Most of these are related to normal scheduler and I/O reasons. However, since Windows is such a GUI-focused operating system, some of the built in reasons are related to the GUI. For example, a process get a priority boost after the GUI thread wakes up and starts execution. Another example is that CPU intensive programs, like video games and video players gets a large boost, and even a special service dedicated to making sure that all of their respective execution requests are seamless. This is again due to the unique focus of Windows on the GUI. \\
    The main differences between processes, threads and scheduling in Windows and FreeBSD overall seem to stem from the developers that are using Windows; in general, many of the ideas and constructs are reimplemented to fit the Windows philosophy. In this case, the focus on the graphical utilities and the want to simplify established terminology and ideas seems to have motivated Microsoft's changes. The reason the scheduler is the same is because the priority-based scheduler has been a tried and true method of mostly-fair scheduling.\\

\end{singlespace}

\section{This is a section}
\begin{singlespace}
This is single space This is single space This is single space This is single space This is single space This is single space This is single space This is single space  This is single space This is single space This is single space This is single space  This is single space This is single space This is single space This is single space  This is single space This is single space This is single space This is single space  

\lstinputlisting{example.c} 
\end{singlespace}

\section{This is a section}
\begin{singlespace}
This is single space This is single space This is single space This is single space This is single space This is single space This is single space This is single space  This is single space This is single space This is single space This is single space  This is single space This is single space This is single space This is single space  This is single space This is single space This is single space This is single space  
\end{singlespace}

\newpage
\bibliographystyle{plain}
\bibliography{bibfile}

\end{document}
